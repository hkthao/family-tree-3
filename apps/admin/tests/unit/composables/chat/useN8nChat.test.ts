// tests/unit/composables/chat/useN8nChat.test.ts
import { describe, it, expect, vi, beforeEach, afterEach, type SpyInstance } from 'vitest';
import { ref, type Ref, type ComputedRef } from 'vue';
import { useN8nChat } from '@/composables/chat/useN8nChat';
import { useI18n } from 'vue-i18n';
import { useAccessToken } from '@/composables/auth/useAccessToken';
import { useUserPreferences } from '@/composables/user/useUserPreferences';
import { N8nChatAdapter } from '@/composables/chat/n8nChat.adapter';
import * as apiUtil from '@/utils/api.util'; // Import apiUtil to mock getEnvVariable

// Mock external dependencies
vi.mock('vue-i18n');
vi.mock('@/composables/auth/useAccessToken');
vi.mock('@/composables/user/useUserPreferences');
vi.mock('@/utils/api.util'); // Mock the module for getEnvVariable

// New ref to control the isMounted state of the mock adapter
const mockIsMountedRef = ref(false);

// Mock the N8nChatAdapter
const mockN8nChatAdapter: N8nChatAdapter = {
  mount: vi.fn(() => {
    mockIsMountedRef.value = true; // Simulate chat being mounted
  }),
  unmount: vi.fn(() => {
    mockIsMountedRef.value = false; // Simulate chat being unmounted
  }),
  isMounted: vi.fn(() => mockIsMountedRef.value), // Now it's a function that returns the ref's value
};

describe('useN8nChat', () => {
  let mockAccessToken: Ref<string | undefined>;
  let mockPreferences: Ref<any>; // Changed type to Ref<any> for flexibility
  let mockGetEnvVariable: SpyInstance;
  let mockT: SpyInstance;

  const WEBHOOK_URL = 'http://test-webhook.com';

  beforeEach(() => {
    vi.useFakeTimers(); // Enable fake timers
    vi.clearAllMocks();

    // Reset the mockIsMountedRef for each test
    mockIsMountedRef.value = false;

    // Correctly mock useAccessToken to return a ref directly
    // This assumes useAccessToken returns an object with accessToken as a ref
    const accessTokenRef = ref('test-token');
    vi.mocked(useAccessToken).mockReturnValue({ accessToken: accessTokenRef });
    mockAccessToken = accessTokenRef;

    const preferencesRef = ref({});
    const currentChatLanguageRef = ref('en');
    vi.mocked(useUserPreferences).mockReturnValue({ preferences: preferencesRef, currentChatLanguage: currentChatLanguageRef });
    mockPreferences = preferencesRef; // Correctly get the ref

    mockGetEnvVariable = vi.mocked(apiUtil.getEnvVariable).mockReturnValue(WEBHOOK_URL);

    mockT = vi.fn((key) => key);
    vi.mocked(useI18n).mockReturnValue({ t: mockT });

    // Reset adapter mocks for each test
    mockN8nChatAdapter.mount.mockClear();
    mockN8nChatAdapter.unmount.mockClear();
  });

  afterEach(() => {
    vi.useRealTimers(); // Restore real timers after each test
  });

  it('should initialize chat when chatOpen is true, access token and preferences are available', async () => {
    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    await vi.runOnlyPendingTimersAsync(); // Allow watchers to run immediately

    expect(mockGetEnvVariable).toHaveBeenCalledWith('VITE_N8N_CHAT_WEBHOOK_URL');
    expect(mockAccessToken.value).toBe('test-token');
    expect(mockPreferences.value).toEqual({});
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledTimes(1);
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledWith(expect.objectContaining({
      webhookUrl: WEBHOOK_URL,
      accessToken: 'test-token',
      targetSelector: '#n8n-chat-target',
      metadata: { familyId: 'family123' },
      defaultLanguage: 'en',
      i18n: expect.any(Object), // Expect the i18n object generated by logic
    }));
  });

  it('should destroy chat when chatOpen becomes false', async () => {
    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    // Initial mount
    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    await vi.runOnlyPendingTimersAsync(); // Run initial watchers
    mockIsMountedRef.value = true; // Simulate chat being mounted after initializeChat

    chatOpen.value = false; // Trigger unmount
    await vi.runOnlyPendingTimersAsync(); // Allow watchers to run

    expect(mockN8nChatAdapter.unmount).toHaveBeenCalledTimes(1);
  });

  it('should not initialize chat if WEBHOOK_URL is not defined', async () => {
    mockGetEnvVariable.mockReturnValue(undefined); // Simulate missing webhook URL

    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    await vi.runOnlyPendingTimersAsync(); // Run initial watchers

    expect(mockN8nChatAdapter.mount).not.toHaveBeenCalled();
  });

  it('should not initialize chat if access token is not available', async () => {
    mockAccessToken.value = undefined; // Simulate missing access token

    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    await vi.runOnlyPendingTimersAsync(); // Run initial watchers

    expect(mockN8nChatAdapter.mount).not.toHaveBeenCalled();
  });

  it('should update chat metadata when selectedFamilyId changes', async () => {
    const selectedFamilyId = ref('initial-family');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    await vi.runOnlyPendingTimersAsync(); // Run initial watchers

    // Initial call to mount would have metadata: { familyId: 'initial-family' }
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledWith(expect.objectContaining({
      metadata: { familyId: 'initial-family' },
    }));

    mockN8nChatAdapter.mount.mockClear(); // Clear initial mount call
    mockIsMountedRef.value = true; // Simulate chat being mounted after initial call

    selectedFamilyId.value = 'new-family';
    await vi.runOnlyPendingTimersAsync(); // Allow watchers to run for reactive updates

    // The composable should handle updating the metadata by destroying and remounting
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledTimes(1); // Expect one more mount call
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledWith(expect.objectContaining({
      webhookUrl: WEBHOOK_URL,
      accessToken: 'test-token',
      targetSelector: '#n8n-chat-target',
      metadata: { familyId: 'new-family' },
      defaultLanguage: 'en',
      i18n: expect.any(Object), // Expect the i18n object generated by logic
    }));
  });

  it('should toggle chatOpen state', async () => {
    const selectedFamilyId = ref(undefined);
    const chatOpen = ref(false);

    const { actions } = useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    expect(chatOpen.value).toBe(false);

    actions.toggleChat();
    await vi.runOnlyPendingTimersAsync(); // Allow watchers to run
    expect(chatOpen.value).toBe(true);

    actions.toggleChat();
    await vi.runOnlyPendingTimersAsync(); // Allow watchers to run
    expect(chatOpen.value).toBe(false);
  });

  it('should return isChatReady computed property based on adapter', async () => {
    const selectedFamilyId = ref(undefined);
    const chatOpen = ref(false);

    const { state } = useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    expect(state.isChatReady.value).toBe(false);

    // Simulate the adapter becoming mounted
    mockIsMountedRef.value = true;
    await vi.runOnlyPendingTimersAsync(); // Allow reactive effects to propagate

    expect(state.isChatReady.value).toBe(true);
  });

  it('should destroy chat on unmount', async () => {
    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    // Initial mount
    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    await vi.runOnlyPendingTimersAsync(); // Run initial watchers
    mockIsMountedRef.value = true; // Simulate chat being mounted

    // Simulate unmounting. In a real Vue component, this would be handled by Vue's lifecycle.
    // For a composable tested directly, we ensure the watchers react to changes.
    chatOpen.value = false;
    await vi.runOnlyPendingTimersAsync(); // Ensure watchers fire

    expect(mockN8nChatAdapter.unmount).toHaveBeenCalledTimes(1);
  });
});