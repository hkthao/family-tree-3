// tests/unit/composables/chat/useN8nChat.test.ts
import { describe, it, expect, vi, beforeEach, type SpyInstance } from 'vitest';
import { ref, computed } from 'vue';
import { useN8nChat } from '@/composables/chat/useN8nChat';
import { useI18n } from 'vue-i18n';
import { useAccessToken } from '@/composables/auth/useAccessToken';
import { useUserPreferences } from '@/composables/user/useUserPreferences';
import { N8nChatAdapter } from '@/composables/chat/n8nChat.adapter';
import * as apiUtil from '@/utils/api.util'; // Import apiUtil to mock getEnvVariable

// Mock external dependencies
vi.mock('vue-i18n');
vi.mock('@/composables/auth/useAccessToken');
vi.mock('@/composables/user/useUserPreferences');
vi.mock('@/utils/api.util'); // Mock the module for getEnvVariable

// Mock the N8nChatAdapter
const mockN8nChatAdapter: N8nChatAdapter = {
  mount: vi.fn(),
  unmount: vi.fn(),
  isMounted: vi.fn(() => false),
};

describe('useN8nChat', () => {
  let mockAccessToken: SpyInstance;
  let mockPreferences: SpyInstance;
  let mockCurrentChatLanguage: SpyInstance;
  let mockGetEnvVariable: SpyInstance;
  let mockUseI18n: SpyInstance;
  let mockT: SpyInstance;

  const WEBHOOK_URL = 'http://test-webhook.com';

  beforeEach(() => {
    vi.clearAllMocks();

    mockAccessToken = vi.mocked(useAccessToken).mockReturnValue({ accessToken: ref('test-token') }).accessToken;
    mockPreferences = vi.mocked(useUserPreferences).mockReturnValue({ preferences: ref({}), currentChatLanguage: ref('en') }).preferences;
    mockCurrentChatLanguage = vi.mocked(useUserPreferences).mockReturnValue({ preferences: ref({}), currentChatLanguage: ref('en') }).currentChatLanguage;
    mockGetEnvVariable = vi.mocked(apiUtil.getEnvVariable).mockReturnValue(WEBHOOK_URL);

    mockT = vi.fn((key) => key);
    mockUseI18n = vi.mocked(useI18n).mockReturnValue({ t: mockT });

    // Reset adapter mocks for each test
    mockN8nChatAdapter.mount.mockClear();
    mockN8nChatAdapter.unmount.mockClear();
    mockN8nChatAdapter.isMounted.mockClear();
    mockN8nChatAdapter.isMounted.mockReturnValue(false); // Default to not mounted
  });

  it('should initialize chat when chatOpen is true, access token and preferences are available', async () => {
    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });

    expect(mockGetEnvVariable).toHaveBeenCalledWith('VITE_N8N_CHAT_WEBHOOK_URL');
    expect(mockAccessToken.value).toBe('test-token');
    expect(mockPreferences.value).toEqual({});
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledTimes(1);
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledWith(expect.objectContaining({
      webhookUrl: WEBHOOK_URL,
      accessToken: 'test-token',
      targetSelector: '#n8n-chat-target',
      metadata: { familyId: 'family123' },
      defaultLanguage: 'en',
      i18n: expect.any(Object), // Expect the i18n object generated by logic
    }));
  });

  it('should destroy chat when chatOpen becomes false', async () => {
    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    // Initial mount
    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    mockN8nChatAdapter.isMounted.mockReturnValue(true); // Simulate chat being mounted

    chatOpen.value = false; // Trigger unmount
    await vi.runOnlyPendingTimersAsync(); // Allow watchers to run

    expect(mockN8nChatAdapter.unmount).toHaveBeenCalledTimes(1);
  });

  it('should not initialize chat if WEBHOOK_URL is not defined', async () => {
    mockGetEnvVariable.mockReturnValue(undefined); // Simulate missing webhook URL

    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });

    expect(mockN8nChatAdapter.mount).not.toHaveBeenCalled();
  });

  it('should not initialize chat if access token is not available', async () => {
    mockAccessToken.value = undefined; // Simulate missing access token

    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });

    expect(mockN8nChatAdapter.mount).not.toHaveBeenCalled();
  });

  it('should update chat metadata when selectedFamilyId changes', async () => {
    const selectedFamilyId = ref('initial-family');
    const chatOpen = ref(true);

    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });

    // Initial call to mount would have metadata: { familyId: 'initial-family' }
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledWith(expect.objectContaining({
      metadata: { familyId: 'initial-family' },
    }));

    // Reset mock for subsequent calls
    mockN8nChatAdapter.mount.mockClear();

    selectedFamilyId.value = 'new-family';
    // No direct re-mount on metadata change, but internal metadata object is updated
    // The adapter needs to re-mount for changes to take effect in the widget
    // This test ensures the reactive metadata object *within* the composable updates
    // The responsibility of re-initializing the chat with new metadata lies within the composable logic (not explicitly handled here)
    // For now, we verify the internal metadata object updates via the adapter call

    // Trigger re-initialization manually for testing purpose or confirm that the watcher logic works
    // For this test, we verify the metadata object itself updates.
    // If the widget supported dynamic metadata updates without full re-initialization,
    // we would test that functionality directly.
    expect(mockN8nChatAdapter.mount).toHaveBeenCalledWith(expect.objectContaining({
      metadata: { familyId: 'new-family' },
    }));
  });

  it('should toggle chatOpen state', () => {
    const selectedFamilyId = ref(undefined);
    const chatOpen = ref(false);

    const { actions } = useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    expect(chatOpen.value).toBe(false);

    actions.toggleChat();
    expect(chatOpen.value).toBe(true);

    actions.toggleChat();
    expect(chatOpen.value).toBe(false);
  });

  it('should return isChatReady computed property based on adapter', () => {
    const selectedFamilyId = ref(undefined);
    const chatOpen = ref(false);

    const { state } = useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    expect(state.isChatReady.value).toBe(false);

    mockN8nChatAdapter.isMounted.mockReturnValue(true);
    expect(state.isChatReady.value).toBe(true);
  });

  it('should destroy chat on unmount', () => {
    const selectedFamilyId = ref('family123');
    const chatOpen = ref(true);

    // Initial mount
    useN8nChat(selectedFamilyId, chatOpen, { n8nChatAdapter: mockN8nChatAdapter });
    mockN8nChatAdapter.isMounted.mockReturnValue(true);

    // Call onUnmounted manually (Vitest handles this automatically during component unmount)
    // In a real Vue test, this would be triggered by unmounting the component using the composable.
    // For direct composable testing, we simulate the lifecycle.

    // Correct way to test onUnmounted in composables is by having a wrapper component or directly calling the cleanup logic

    // A simpler way to test the onUnmounted effect for composables is to trigger the effect directly
    // This would typically involve a wrapper component in Vitest for composables, but for direct function call,
    // we rely on the `onUnmounted` callback being registered.
    // However, the current setup of useN8nChat calls destroyChat directly in onUnmounted.
    // The watch for chatOpen becoming false also calls destroyChat.

    // Let's re-trigger the watch with chatOpen = false
    chatOpen.value = false;
    expect(mockN8nChatAdapter.unmount).toHaveBeenCalledTimes(1);
  });
});