// test/unit/search_provider_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:family_tree/providers/search_provider.dart';
import 'package:family_tree/services/api_service.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

import 'search_provider_test.mocks.dart'; // Generated by build_runner



@GenerateMocks([ApiService])
void main() {
  group('searchProvider', () {
    test('debounces search and returns results', () async {
      final mockApiService = MockApiService();
      when(mockApiService.search('rolex')).thenAnswer((_) async => [
            {"id": "w1", "type": "watch", "title": "Rolex Submariner", "brand": "Rolex", "year": 1967, "thumbnail": "https://example.com/img1.jpg"}
          ]);

      final container = ProviderContainer(
        overrides: [
          apiServiceProvider.overrideWithValue(mockApiService),
        ],
      );

      // Initial state should be empty
      expect(container.read(searchResultsProvider), const AsyncValue<List<dynamic>>.loading());

      // Set a query
      container.read(searchQueryProvider.notifier).state = 'rol';
      await Future.delayed(const Duration(milliseconds: 100)); // Not enough for debounce

      // Change query before debounce
      container.read(searchQueryProvider.notifier).state = 'rolex';
      await Future.delayed(const Duration(milliseconds: 400)); // Allow debounce to pass

      final results = await container.read(searchResultsProvider.future);
      expect(results.length, 1);
      expect(results[0].title, 'Rolex Submariner');

      verify(mockApiService.search('rolex')).called(1);
      verifyNoMoreInteractions(mockApiService);

      container.dispose();
    });

    test('returns empty list for empty query', () async {
      final mockApiService = MockApiService();
      final container = ProviderContainer(
        overrides: [
          apiServiceProvider.overrideWithValue(mockApiService),
        ],
      );

      container.read(searchQueryProvider.notifier).state = '';
      await Future.delayed(const Duration(milliseconds: 400)); // Allow debounce to pass

      final results = await container.read(searchResultsProvider.future);
      expect(results, isEmpty);

      verifyZeroInteractions(mockApiService); // Should not call API for empty query

      container.dispose();
    });
  });
}
