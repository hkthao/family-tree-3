using System.Text.Json;
using System.Text.Json.Serialization;
using backend.Application.Common.Interfaces;
using backend.Application.Common.Models;
using backend.Domain.Enums;
using FluentValidation.Results;
using Microsoft.Extensions.Logging;

namespace backend.Application.Relationships.Commands.GenerateRelationshipData;

public class GenerateRelationshipDataCommandHandler(IChatProviderFactory chatProviderFactory, IValidator<AIRelationshipDto> aiRelationshipDtoValidator, IApplicationDbContext context, IAuthorizationService authorizationService, ILogger<GenerateRelationshipDataCommandHandler> logger) : IRequestHandler<GenerateRelationshipDataCommand, Result<List<AIRelationshipDto>>>
{
    private readonly IChatProviderFactory _chatProviderFactory = chatProviderFactory;
    private readonly IValidator<AIRelationshipDto> _aiRelationshipDtoValidator = aiRelationshipDtoValidator;
    private readonly IApplicationDbContext _context = context;
    private readonly IAuthorizationService _authorizationService = authorizationService;
    private readonly ILogger<GenerateRelationshipDataCommandHandler> _logger = logger;

    public async Task<Result<List<AIRelationshipDto>>> Handle(GenerateRelationshipDataCommand request, CancellationToken cancellationToken)
    {
        var chatProvider = _chatProviderFactory.GetProvider(ChatAIProvider.Local); // Assuming Local for now

        string systemPrompt = "You are an AI assistant that generates JSON data for relationship entities based on natural language descriptions. The output MUST be a single JSON object, and ONLY the JSON object. Do NOT include any conversational text, explanations, or markdown formatting (e.g., ```json). The JSON object MUST start with '{' and end with '}'. Each object in the \"relationships\" array should have the following fields: - \"sourceMemberName\" (full name) - \"targetMemberName\" (full name) - \"type\" (MUST be one of: Father, Mother, Wife, Husband - case-sensitive) - \"order\" (Optional: integer representing birth order, e.g., 1 for first child, 2 for second child) - \"startDate\" (YYYY-MM-DD. If only year is provided, default to YYYY-01-01. If invalid, leave as null) - \"endDate\" (YYYY-MM-DD. If only year is provided, default to YYYY-01-01. If invalid, leave as null) - \"description\". If details are missing, use placeholders (\"Unknown\" or null) instead of leaving fields empty. Infer the entity type (Relationship) from the prompt. If the prompt describes multiple entities, include them in the respective arrays. Example input: Tạo mối quan hệ giữa Nguyễn Văn A và Trần Thị B. Nguyễn Văn A là chồng của Trần Thị B, kết hôn vào ngày 2000-01-15. Mối quan hệ này được mô tả là một cặp vợ chồng hạnh phúc. Tạo mối quan hệ giữa Nguyễn Văn A và Nguyễn Văn C. Nguyễn Văn A là cha của Nguyễn Văn C, sinh năm 2005. Nguyễn Văn C là con thứ nhất. Example output: { \"relationships\": [ { \"sourceMemberName\": \"Nguyễn Văn A\", \"targetMemberName\": \"Trần Thị B\", \"type\" : \"Husband\", \"startDate\": \"2000-01-15\", \"endDate\": null, \"description\": \"Happy married couple\" }, { \"sourceMemberName\": \"Nguyễn Văn A\", \"targetMemberName\": \"Nguyễn Văn C\", \"type\" : \"Father\", \"order\": 1, \"startDate\": \"2005-01-01\", \"endDate\": null, \"description\": \"Parent-child relationship\" } ] }.";

        var userPrompt = request.Prompt;

        var chatMessages = new List<ChatMessage>
        {
            new() { Role = "system", Content = systemPrompt },
            new() { Role = "user", Content = userPrompt }
        };

        string jsonString = await chatProvider.GenerateResponseAsync(chatMessages);
        jsonString = jsonString.Trim(); // Trim whitespace
        _logger.LogInformation("AI generated JSON response: {JsonString}", jsonString); // Log AI response

        if (string.IsNullOrWhiteSpace(jsonString))
        {
            _logger.LogWarning("AI did not return a response for prompt: {Prompt}", request.Prompt); // Log warning
            return Result<List<AIRelationshipDto>>.Failure("AI did not return a response.");
        }

        try
        {
            var aiResponse = JsonSerializer.Deserialize<AIResponseData>(jsonString, new JsonSerializerOptions { PropertyNameCaseInsensitive = true, Converters = { new JsonStringEnumConverter() } });

            if (aiResponse == null || aiResponse.Relationships == null || aiResponse.Relationships.Count == 0)
            {
                _logger.LogInformation("No relationships generated by AI for prompt: {Prompt}", request.Prompt); // Log information
                return Result<List<AIRelationshipDto>>.Success([]); // Return empty list if no relationships generated
            }

            _logger.LogInformation("Successfully generated {Count} relationships from AI for prompt: {Prompt}", aiResponse.Relationships.Count, request.Prompt); // Log success

            foreach (var relationshipDto in aiResponse.Relationships)
            {
                relationshipDto.ValidationErrors ??= [];

                // Resolve SourceMemberId from SourceMemberName
                if (!string.IsNullOrWhiteSpace(relationshipDto.SourceMemberName))
                {
                    // Split FullName into LastName and FirstName
                    var nameParts = relationshipDto.SourceMemberName.Split(' ', 2); // Split into at most 2 parts
                    string lastName = nameParts.Length > 0 ? nameParts[0] : string.Empty;
                    string firstName = nameParts.Length > 1 ? nameParts[1] : string.Empty;

                    var sourceMember = await _context.Members
                        .Where(m => m.LastName == lastName && m.FirstName == firstName)
                        .FirstOrDefaultAsync(cancellationToken);

                    if (sourceMember != null)
                    {
                        var authResult = _authorizationService.CanAccessFamily(sourceMember.FamilyId);
                        if (authResult)
                            relationshipDto.SourceMemberId = sourceMember.Id;
                        else
                            relationshipDto.ValidationErrors.Add($"No permission to access family of {relationshipDto.SourceMemberName}.");
                    }
                    else
                    {
                        relationshipDto.ValidationErrors.Add($"Source member '{relationshipDto.SourceMemberName}' not found.");
                    }
                }

                // Resolve TargetMemberId from TargetMemberName
                if (!string.IsNullOrWhiteSpace(relationshipDto.TargetMemberName))
                {
                    // Split FullName into LastName and FirstName
                    var nameParts = relationshipDto.TargetMemberName.Split(' ', 2); // Split into at most 2 parts
                    string lastName = nameParts.Length > 0 ? nameParts[0] : string.Empty;
                    string firstName = nameParts.Length > 1 ? nameParts[1] : string.Empty;

                    var targetMember = await _context.Members
                        .Where(m => m.LastName == lastName && m.FirstName == firstName)
                        .FirstOrDefaultAsync(cancellationToken);

                    if (targetMember != null)
                    {
                        var authResult = _authorizationService.CanAccessFamily(targetMember.FamilyId);
                        if (authResult)
                            relationshipDto.TargetMemberId = targetMember.Id;
                        else
                            relationshipDto.ValidationErrors.Add($"No permission to access family of {relationshipDto.TargetMemberName}.");
                    }
                    else
                    {
                        relationshipDto.ValidationErrors.Add($"Target member '{relationshipDto.TargetMemberName}' not found.");
                    }
                }

                // Validate AIRelationshipDto
                ValidationResult validationResult = await _aiRelationshipDtoValidator.ValidateAsync(relationshipDto, cancellationToken);
                if (!validationResult.IsValid)
                {
                    relationshipDto.ValidationErrors.AddRange(validationResult.Errors.Where(e => e.ErrorMessage != null).Select(e => e.ErrorMessage!));
                }
            }
            return Result<List<AIRelationshipDto>>.Success(aiResponse.Relationships);
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "AI generated invalid JSON. Details: {Message}", ex.Message);
            return Result<List<AIRelationshipDto>>.Failure($"AI generated invalid JSON: {ex.Message}");
        }
        catch (Exception ex)
        {
            return Result<List<AIRelationshipDto>>.Failure($"An unexpected error occurred while processing AI response: {ex.Message}");
        }
    }

    private class AIResponseData
    {
        public List<AIRelationshipDto>? Relationships { get; set; }
    }
}
